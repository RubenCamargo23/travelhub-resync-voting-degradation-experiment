<div style="padding: 20px;">
    <h1>Experimentos Sprint 1</h1>

    <div style="border: 1px solid #ccc; padding: 10px; margin-bottom: 10px;">
        <h2>Hipótesis 1: Si un microservicio cae y vuelve, puede resincronizar su estado automáticamente</h2>
        <p>Crea una reserva y verifica que el Inventario (logs) procese el evento.</p>

        <h3>Tácticas de Arquitectura:</h3>
        <ul>
            <li>
                <strong>State Recovery Manager:</strong> Reconstrucción del estado del servicio a partir del Event Log.
                <br><em>Implementación:</em> Tabla <code>reservation_events</code> persiste todos los cambios.
                Inventario consulta esta tabla al iniciar para sincronizarse sin depender de Reservas.
            </li>
            <li>
                <strong>Comunicación Asíncrona:</strong> Reducción del acoplamiento temporal mediante propagación de
                eventos.
                <br><em>Implementación:</em> Patrón <strong>Outbox</strong>. Reservas guarda el evento localmente y
                responde inmediatamente. Un <strong>Polling Consumer</strong> en Inventario procesa los eventos
                pendientes asíncronamente.
            </li>
        </ul>

        <button (click)="testH1()">Crear Reserva</button>
        <pre>{{ h1Result | json }}</pre>
    </div>

    <div style="border: 1px solid #ccc; padding: 10px; margin-bottom: 10px;">
        <h2>Hipótesis 2: Un sistema de votación con 5 réplicas puede detectar una réplica defectuosa mediante consenso
        </h2>
        <p>Intenta pagar una reserva usando 5 réplicas (una fallará).</p>

        <h3>Tácticas de Arquitectura:</h3>
        <ul>
            <li>
                <strong>Replicación de Servicios (Active-Active):</strong> Redundancia mediante múltiples instancias
                activas.
                <br><em>Implementación:</em> <code>ThreadPoolExecutor</code> lanza 5 peticiones HTTP paralelas a
                instancias (`replica_id=1..5`) del servicio de Pagos.
            </li>
            <li>
                <strong>Votación (Voting) / Consenso:</strong> Comparación de resultados para enmascarar fallos
                bizantinos.
                <br><em>Implementación:</em> Algoritmo de mayoría simple (>=3) usando <code>Counter</code>. Valida si la
                respuesta más común es correcta y descarta la minoría errónea.
            </li>
        </ul>

        <button (click)="testH2()">Pagar Reserva (Consenso)</button>
        <pre>{{ h2Result | json }}</pre>
    </div>

    <div style="border: 1px solid #ccc; padding: 10px; margin-bottom: 10px;">
        <h2>Hipótesis 3: Un Circuit Breaker puede degradar funcionalidad automáticamente sin que el usuario perciba
            error</h2>
        <p>Busca a través del Gateway. Si Busqueda cae, verás respuesta fallback.</p>

        <h3>Tácticas de Arquitectura:</h3>
        <ul>
            <li>
                <strong>Circuit Breaker:</strong> Detección y aislamiento de fallos para evitar cascadas.
                <br><em>Implementación:</em> Lógica en <strong>API Gateway</strong> cuenta fallos consecutivos
                (Threshold=3). Si se supera, bloquea tráfico hacia Busqueda por 30s (Open State).
            </li>
            <li>
                <strong>Degradación Funcional (Functional Degradation):</strong> Ofrecer funcionalidad reducida en lugar
                de fallar completamente.
                <br><em>Implementación:</em> El Gateway retorna un JSON <em>fallback</em> (datos estáticos/vacíos)
                cuando el circuito está abierto, evitando error 500 al cliente.
            </li>
        </ul>

        <button (click)="testH3()">Buscar</button>
        <pre>{{ h3Result | json }}</pre>
    </div>
</div>